# iam-role-eks

## Objective
Deploy AWS Resources and create IAM roles to be assumed by an EKS cluster

### Prerequisites
- EKS cluster with IAM OIDC provider enabled
- AWS long term credentials with an AdministratorAccess policy, the example create AWS Roles (this can be adjusted later in production with with IAM boundaries and fine grained policies)

## Example Terraform Architecture
- `terraform/parameter`: AWS SSM Parameter (plain text) --- AWS Resources in general, one or more.
- `terraform/policy`: AWS IAM Managed Policy (allows a role to access parameters tagged with `Humanitec:true`) --- AWS Policies, often references the previous module (gets the resources ARNs and IDs), one or more of these.
- `terraform/role`: AWS IAM Role that can be assumed from a specific EKS cluster, namespace and service account. --- One per workload, the role. It references the policies generated by the prior module(s).
- `main.tf`: Humanitec Resource definitions

## Humanitec Architecture
The architecture for resource definitions relies on the [workload](https://docs.humanitec.com/integrations/resource-types/workload) resource type.
This resource receives the current context of a workload (say - the backend portion) from an Application, for a current environment

You would use this resource to create workload scoped resources (so they will be configured for each environment), for instance, if you were configuring a CloudFront distribution, you will end with three of them if you had 3 environments.

### Example of production-like architecture:
Requirements: S3 buckets and access points, RDS Database, DynamoDB database for the app "MyApp"

Option 1:
- `terraform/myapp/s3`: `Input`: context; `Exports`: Bucket ARNs, Access points ARN and a Managed Policy that allows the app to interact with S3 Resources.
- `terraform/myapp/rds`: `Input`: context; `Exports`: RDS endpoints, credentials a Managed Policy.
- `terraform/myapp/ddb`: `Input`: context; `Exports`: DynamoDB table names, Managed Policy.
- `terraform/myapp/role`: `Input`: context, 3 managed policies; Exports`: A role to be used by the workload.

Option 2:
- `terraform/myapp/s3`: `Input`: context; `Exports`: Bucket ARNs, Access points ARN.
- `terraform/myapp/s3policy`: `Input`: context; `Exports`: Managed Policy that allows the app to interact with S3 resources.
- `terraform/myapp/rds`: `Input`: context; `Exports`: RDS endpoints, credentials.
- `terraform/myapp/rdspolicy`: `Input`: context; `Exports`: Managed Policy that allows the app to interact with RDS resources.
- `terraform/myapp/ddb`: `Input`: context; `Exports`: DynamoDB table names.
- `terraform/myapp/ddbpolicy`: `Input`: context; `Exports`: Managed Policy that allows the app to interact with DDB resources.
- `terraform/myapp/role`: `Input`: context, 3 managed policies; `Exports`: A role to be used by the workload.

The `context` is everything that is needed for the resource to be provisioned, such as: Region, Access keys, Prefixes, Cluster IDs, Namespaces, Service Accounts, etc. These values can in fact come from output of other resources, like custom Terraform lookup ones that go to a Vault.

These repositories can be on different GitHub repositories, and have their own Access and Secret keys, allowing to scope privileges for deployment. The example assumes `AdministratorAccess`.

## Example Humanitec Architecture
Within `main.tf` you will find context variables at the beginning.

Below that, you will find:

- `resource "humanitec_resource_definition" "aws_terraform_resource_ssm_parameter"`:
    - Configures a resource definition, points to the GitHub repository and provides context parameter to generate custom parameter names
    - This is where you put your own resources, and export Resource IDs
- `resource "humanitec_resource_definition" "aws_terraform_resource_ssm_policy"`:
    - This is where you export a managed policy, that is capable of interact with the resources created earlier
- `resource "humanitec_resource_definition" "aws_terraform_resource_role"`:
    - This is where you create a role that references all the policies above
- `resource "humanitec_resource_definition" "aws_eks_namespace"`:
    - This resource creates a custom namespace with the name of your application and environment, used to configure the OIDC EKS policy.
- `resource "humanitec_resource_definition" "aws_eks_injector"`:
    - This resource takes all the outputs and injects them on the manifest to be deployed, basically configures the service account and environment variables

Note that is possible to reference a terraform output, as `Input` on another resource using this format `"$${resources.workload#aws-terrafom-eks-ssm-policy.outputs.policy_ssm}"` [More Information here](https://docs.humanitec.com/reference/concepts/resources/references).

What if you'd like to just provide an existing role to a service account? Modify `resource "humanitec_resource_definition" "aws_eks_injector"` accordingly, instead of referencing `eks.amazonaws.com/role-arn: $${resources.workload#aws-terrafom-eks-role.outputs.role}` you could directly add `eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/myapp-$${context.app.id}-$${context.env.id}-{{trimPrefix "modules." "$${context.res.id}"}}`  for a dynamic role scoped per environment, the end result will look like `arn:aws:iam::ACCOUNT_ID:role/myapp-test-myeksapp-development`

## App Configuration within Humanitec
The App can be configured with Score, Humanitec CLI, API or the UI. Below is a video on how to configure the example application and verify its funcitonality:
https://humanitec-cse.s3.amazonaws.com/example-eks-iam-roles.mov

### Git Credentials
The example above goes to public Github, to configure a private git repository, you could adjust credentials like the example below:

```
  driver_inputs = {
    secrets = {
      variables = jsonencode({
        access_key = var.access_key
        secret_key = var.secret_key

      })
      source = jsonencode({
        ssh_key  = var.ssh_key # SSH Private Key (for connections over SSH). (Optional)
        password = var.password # Password or Personal Account Token. (Optional)
      })

    },
    values = {
      "source" = jsonencode(
        {
          path     = "iam-role-eks/terraform/parameter/"
          rev      = "refs/heads/main"
          url      = "https://github.com/MYPRIVATEORG/my-app-resources.git"
          username = var.username # User Name to authenticate. Default is `git`. 
        }
      )
      "variables" = jsonencode(
        {
          region          = var.region
        }
      )
    }
  }
  ```